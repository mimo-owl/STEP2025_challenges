# Documentation for Week3 Challenges
### Author: Mimo Shirasaka

## Challenge 1
### 問題<br>
モジュール化されたプログラムを変更して、「*」「/」に対応しよう<br>
例： 3.0 + 4 * 2 − 1 / 5<br>
不正な入力はないと仮定してよい<br>
細かい仕様は好きに定義してください<br>

### 解き方の概要<br>
#### 記号の読み取り
加減計算と同様に、read_multiplication()とread_divide()関数を作成し、`*`と`/`を読み取って tokenize できるようにした。<br>
#### 計算方法
ポイント：まず乗除計算を終わらせ、その後にもう一回tokensを見ていき、加減計算を行う！<br>
1. まず tokens の中の数字を前から順に見ていき、ある数字の直前（index-1）のトークンが MULTIPLY または DIVIDE である場合、乗除計算をする<br>
2. 乗除計算をしたときは、その結果を `tokens[index-2]` を置換する形で保存し、`index`と`index-1`はtokensから削除する<br>
3. 最後まで見ていって、全ての乗除計算が終わったらもう一度、今度は `+`と`-`だけになった状態の tokens を前から順に見ていき、加減計算を行なう<br>

## Challenge 2
## 問題<br>
書いたプログラムが正しく動いていることを確認するためのテストケースを追加しよう<br>
できるだけ網羅的に<br>

## 工夫したことメモ<br>
工夫したことは以下である。<br>
- 各テストケースで何を検証しているかが後から分かるよう、コメントを入れた<br>
- 順番を入れ替える、多種類の加減、乗除記号を組み合わせる、最大8桁なので、最大桁数のテストケースを入れる、などして網羅性を試みた<br>

## Challenge 3
## 問題<br>
括弧に対応しよう<br>
例:  (3.0 + 4 * (2 − 1)) / 5<br>
テストケースも追加してください<br>
いろいろな解き方があります（5 種類以上）<br>

## 私の解いた方法
#### 記号の読み取り
加減、乗除計算の時と同様に、read_open_bracket()とread_close_bracket()関数を作成し、`(`と`)`を読み取れるようにした。<br>
#### 計算方法
ポイント：まず（）内について内側かつ前側から順に計算を終わらせ、その上で課題１と同様、（）がなくなったシンプルな状態で加減、乗除計算を行う！<br>
--> この方針で、下記のように計算することで、多層になっている()計算にも対応できる電卓プログラムを作ることができた。<br>

* tokens に `(` または `)` が含まれている限り、以下の 1〜5 を繰り返す。すべての括弧が処理されたら、6 を実行する。
1. 計算順序が1番目の()の中身を特定する<br>
tokens を前から順に見ていき、`)`が来たらそこで止める。ここで、この index までは到達したことを記録するために、`seen_index`という変数を作り、indexを記録する。
2. index から`(`が来るまで遡る。すると、この `(`と先ほどの`)`の間が、まず計算すべき部分になる。よって、その中身を一時的な tokens `tmp_tokens`に格納し、課題1と同様に計算する。<br>
3. （）内の計算が終わったら、tokens の`(`の index に、計算結果を格納。
4. tokensを更新する<br>
新たなtokensは、`(`のindexまでの部分と、先ほど記録した`)`のindex `seen_index`以降を結合したものになる。<br>
5. 以後、次は、`(`のindexの次から見ていき、上記 1 ~ 4 を繰り返していく。<br>
6. 最後、tokens にひとつも `(` と `)`がともになくなったら、課題1と同様、最後に1回、乗除加減計算を行う。これにより、すべての計算が完了する。

## Challenge 4
## 問題<br>
abs(), int(), round() に対応しよう<br>
abs(-2.2) => 2.2 （絶対値）<br>
int(1.55) => 1（小数を切捨てる）<br>
round(1.55) => 2（四捨五入）<br>

テストケースも追加してください <br>
例: 12 + abs(int(round(-1.55) + abs(int(-2.3 + 4)))) <br>

## 私の解いた方法
#### 記号の読み取り
課題1~3と同様に、read_abs(), read_int(), read_float() という関数を作成し、`abs` `int` `float` も読み取れるようにした。<br>
#### 計算方法
課題3で、計算すべき（）を探していった。ここでは、その計算対象となる（）が見つかると、（の直前に、`abs` `int` `float`のいずれかが付与されていないかを確認するようにした。あれば、（）内の計算結果について、`abs` `int` `float`等所定の処理を施す。<br>

`abs` `int` `float`がついているときとそうでない時で、tokensの更新すべき方法が異なることに気づき、has_prefrix というフラグを設け、場合分けして処理するように工夫した。

